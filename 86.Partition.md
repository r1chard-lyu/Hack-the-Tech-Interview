# 86. Partition List
https://leetcode.com/problems/partition-list/description/

## Sol. Two List
1. Approch
- 創造兩個 Linked List (list1 and list2)
- 從頭 traversal 一次 head
- 將 node->val < x 存到 list1, node->val > x 存到 list2
- 將 list2 接到 list1 後面回傳
	```c++
	/**
	* Definition for singly-linked list.
	* struct ListNode {
	*     int val;
	*     ListNode *next;
	*     ListNode() : val(0), next(nullptr) {}
	*     ListNode(int x) : val(x), next(nullptr) {}
	*     ListNode(int x, ListNode *next) : val(x), next(next) {}
	* };
	*/
	class Solution {
	public:
		ListNode* partition(ListNode* head, int x) {
		
		if (!head) 
			return nullptr;

		ListNode* list1 = new ListNode(-1);
		ListNode* tail1 = list1;

		ListNode* list2 = new ListNode(-1);
		ListNode* tail2 = list2;
		
		while (head != nullptr) { // <-- X head->next != nullptr => miss final node
			if (head->val < x) {
				tail1->next = head;
				tail1 = tail1->next;
			} else if (head->val >= x) {
				tail2->next = head;
				tail2 = tail2->next;
			}
			head = head->next;
		}

		tail1->next = list2->next;
		tail2->next = nullptr;
		ListNode* result = list1->next; // <-- miss this because of cycle
		
		delete list1;
		delete list2;

		return result;
		}
	};
	``` 
2. Analysis
- Time Complexity: O(N)
	- head traversal: O(N)
	- total: O(N)
- Space Complexity: O(1) 
	- list1 dummy and tail: O(1)
	- list2 dummy and tail: O(1)
	- total: O(1) + O(1) = O(1)
3. Note
- 注意 Edge Condition
- 注意有沒有 Cycle
- heap 在 function return 之後不會自動釋放空間, 所以記得要 free list1 跟 list2
- Stack 在 function return 後會自動釋放空間, 所以不用 free tail1 跟 tail2
