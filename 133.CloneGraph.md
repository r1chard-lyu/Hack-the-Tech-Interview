# 133. Clone Graph
https://leetcode.com/problems/clone-graph/description/

## Sol. DFS
1. Approch
- 題目要 Clone 一個 Graph, 會給一個 Graph 的 Node*
- 拿到這個 Graph 的 Node* 先檢查是不是 nullptr, 是的話 return
- 不是的化，使用 DFS 展開去搜索這張圖, 接下來要思考怎麼設計 DFS function
- DFS 的 Intput 一定包含一個 Node*, 另外會需要一個 mp 來記錄拜訪過的 Node*, 否則當有環出現，會出現無限制迴圈 (ps. 樹德不一定要 mp, 因為 樹沒有 cycle)
    ```c++
    /*
    // Definition for a Node.
    class Node {
    public:
        int val;
        vector<Node*> neighbors;
        Node() {
            val = 0;
            neighbors = vector<Node*>();
        }
        Node(int _val) {
            val = _val;
            neighbors = vector<Node*>();
        }
        Node(int _val, vector<Node*> _neighbors) {
            val = _val;
            neighbors = _neighbors;
        }
    };
    */

    class Solution {
    public:
        Node* cloneGraph(Node* node) {
            if (node == nullptr) 
                return nullptr;

            unordered_map<Node*, Node*> mp;
            return dfs(node, mp);
        }
    private:
        Node* dfs(Node* curr, unordered_map<Node*, Node*>& mp) {

            if (mp.count(curr)) {
                return mp[curr];
            }

            Node* clone = new Node(curr->val);

            mp[curr] = clone;

            for (Node* nei : curr->neighbors) {
                clone->neighbors.push_back(dfs(nei, mp));
            }

            return clone;
        }
    };
    ```
2. Analysis
- Time Complexity: O(V + E)
    - vertices: O(V)
	- edges: O(E)
    - total: O(V) + O(E) = O(V + E)
- Space Complexity: O(1) 
	- mp: O(V)
    - DFS V: O(V) (Worst-case)
	- total: O(V) + O(V) = O(V)
3. Note.
- 這一題考 Graph 的 DFS 跟 Deep Copy
- Graph 的 DFS 通常會需要 mp (通常用 unordered_map 創造 hashtable) 去紀錄拜訪過的 Node。 因為 Graph 可能會有 Cycle, Tree 則不會有這個問題, 因為 Tree 沒有 Cycle
- Graph 的 DFS 如果有傳遞 hash map 要用 pass-by-reference, 才會是傳原本的 hash table, 如果使用 pass-by-value, 每一次都會複製一份新的，記憶體開銷會很大，而且 hash table 的值不會被傳遞過去。
- Pass-by-refrence vs Pass-by-address 差別?
    - Pass-by-refrence: 
        - C++ 通常使用這個
        - 一個變數的別名 (Alias)
        - 不可以爲 NULL
        - 終身綁定初始化時的變數
        - func(x)
        - 須連接到一個合法的 Object, C++ 規定 Reference 初始化的時候一定要綁定某個變數
        - eg.
            ```c++
            void addOnePtr(int& r) {
                r++;
            }

            int main() {
                int num = 5;
                addOneRef(num);
                return 0;
            }
            ```

    - Pass-by-address
        - C 語言通常使用這個
        - 一個存著記憶體位址的變數
        - 可以爲 NULL
        - 可以隨時改指別人
        - eg.
            ```c
            void addOnePtr(int* p) {
                (*p)++;
            }

            int main() {
                int num = 5;
                addOneRef(num);
                return 0;
            }
            ```

- unordered_map.count 用於檢查 key 有沒有在 map 裡
- Pointer Member Access vs Direct Member Access
    - pointer->member vs object.member
    - clone->neighbors vs myNode.neighbors
        - clone->neighbors = (*clone).neighbors <= 取值 (dereference) 後得到 clone object, 然後用 `.` 來存取成員
- Class
    - Constructor: 
        - Name: 必須與 class 命名相同
        - Purpose: 用於建立 Object
        - Eg.
            - Node* a = new Node();
                - a->val = 0
                - a->neighbors = {}
            - Node* a = new Node(1);
                - a->val = 1
                - a->neighbors = {}
            - Node* a = new Node(1, {b, c});
                - a->val = 1
                - a->neighbors = {b, c}
    - Method: 
        - Name: 任意
        - Purpose: 操作 Object
    - Destructor
        - Name: ~ + class 命名
        - Purpose: Object 被刪除時會自動釋放記憶體與資源
        - C++ 編譯器會自動加入 Destructor
        - 什麼時候需要自己寫 destructor
            - new object in class
            - malloc
            - file handle
            - socket handle
            - thread 
        - 什麼時候不需要 destructor
            - 基本函式庫的實作都遵從 RAII
            - int, double
            - std::vector
            - std::string
            - std::map
            - std::unique_ptr
            - std::shared_ptr
    - RAII
        - Resource Acquisition Is Initialization
        - = Constructor + Destructor
        - RAII vs GC (Garbage Collection)
            - Garbage Collection(c++ 沒有)
                - Runtime Managed, 不可預期資源管理
            - RAII
                - 寫程試的時候就會知道，可預期資源管理
