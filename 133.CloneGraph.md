# 133. Clone Graph
https://leetcode.com/problems/clone-graph/description/

## Sol. DFS
1. Approch
- 題目要 Clone 一個 Graph, 會給一個 Graph 的 Node*
- 拿到這個 Graph 的 Node* 先檢查是不是 nullptr, 是的話 return
- 不是的化，使用 DFS 展開去搜索這張圖, 接下來要思考怎麼設計 DFS function
- DFS 的 Intput 一定包含一個 Node*, 另外會需要一個 mp 來記錄拜訪過的 Node*, 否則當有環出現，會出現無限制迴圈 (ps. 樹德不一定要 mp, 因為 樹沒有 cycle)
- 
    ```c++
    /*
    // Definition for a Node.
    class Node {
    public:
        int val;
        vector<Node*> neighbors;
        Node() {
            val = 0;
            neighbors = vector<Node*>();
        }
        Node(int _val) {
            val = _val;
            neighbors = vector<Node*>();
        }
        Node(int _val, vector<Node*> _neighbors) {
            val = _val;
            neighbors = _neighbors;
        }
    };
    */

    class Solution {
    public:
        Node* cloneGraph(Node* node) {
            if (node == nullptr) 
                return nullptr;

            unordered_map<Node*, Node*> mp;
            return dfs(node, mp);
        }
    private:
        Node* dfs(Node* curr, unordered_map<Node*, Node*>& mp) {

            if (mp.count(curr)) {
                return mp[curr];
            }

            Node* clone = new Node(curr->val);
            
            mp[curr] = clone;

            for (Node* nei : curr->neighbors) {
                clone->neighbors.push_back(dfs(nei, mp));
            }

            return clone;
        }

    };
    ```
2. Analysis
- Time Complexity: O(V + E)
    - vertices: O(V)
	- edges: O(E)
    - total: O(V) + O(E) = O(V + E)
- Space Complexity: O(1) 
	- mp: O(V)
    - DFS V: O(V) (Worst-case)
	- total: O(V) + O(V) = O(V)
3. Note.
- Graph 的 DFS 通常會需要 mp (通常用 unordered_map 創造 hashtable) 去紀錄拜訪過的 Node, 因為 Graph 可能會有 Cycle, Tree 則不會有這個問題, 因為 Tree 沒有 Cycle
- unordered_map.count 用於檢查 key 有沒有在 map 裡
- Class
    - Constructor: 
        - Name: 必須與 class 命名相同
        - Purpose: 用於建立 Object
        - Eg.
            - Node* a = new Node();
                - a->val = 0
                - a->neighbors = {}
            - Node* a = new Node(1);
                - a->val = 1
                - a->neighbors = {}
            - Node* a = new Node(1, {b, c});
                - a->val = 1
                - a->neighbors = {b, c}
    - Method: 
        - Name: 任意
        - Purpose: 操作 Object
    - Destructor
        - Name: ~ + class 命名
        - Purpose: Object 被刪除時會自動釋放記憶體與資源
        - C++ 編譯器會自動加入 Destructor
        - 什麼時候需要自己寫 destructor
            - new object in class
            - malloc
            - file handle
            - socket handle
            - thread 
        - 什麼時候不需要 destructor
            - 基本函式庫的實作都遵從 RAII
            - int, double
            - std::vector
            - std::string
            - std::map
            - std::unique_ptr
            - std::shared_ptr
    - RAII
        - Resource Acquisition Is Initialization
        - = Constructor + Destructor
        - RAII vs GC (Garbage Collection)
            - Garbage Collection(c++ 沒有)
                - Runtime Managed, 不可預期資源管理
            - RAII
                - 寫程試的時候就會知道，可預期資源管理
