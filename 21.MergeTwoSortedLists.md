# 21. Merge Two Sorted Lists

https://leetcode.com/problems/merge-two-sorted-lists/description/


Sol.1 Brute Force
----
1. approch
- 先將兩個 Linked List 的 Node 放到 Vector
- 再去 Sort 這個 Vector
- 再將這個 Vector 轉為 Linked List and return merge list

    ```c++
    /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

            vector<int> vals;

            ListNode* p1 = list1;
            ListNode* p2 = list2;

            while (p1 != nullptr) {
                vals.push_back(p1->val);
                p1 = p1->next;
            }

            while (p2 != nullptr) {
                vals.push_back(p2->val);
                p2 = p2->next;
            }

            if (vals.empty()) {
                return nullptr;
            }

            sort(vals.begin(), vals.end());

            ListNode* dummyHead = new ListNode();
            ListNode* tail = dummyHead;

            for (int v : vals) {
                tail->next = new ListNode(v);
                tail = tail->next;
            }

            return dummyHead->next;
        }
    };
    ```

2. Analysis
- Time Complexity: O(N log N), where N = n + m
    - list 1 + list 2: O(n) + O(m) = O(N)
    - sort: O(N logN)
    - new list: O(N)
    - total: O(N) + O(N log N) + O(N) = O(N log N), where N = n + m
- Space Complexity: O(N), where N = n + m
    - new Vector: O(N)
    - new linked list: O(N)
    - total: O(N) + O(N) = O(N), where N = m + n


## Sol.2 Two Pointers
1. Approch
- 先同時比較兩個 Linked List 的 Node->val 的大小
- 將比較小的接在比較大的後面
- 最後剩餘比較長的 Linked List 直接接上去就好

    ```c++
    /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
            ListNode* dummy = new ListNode(0);
            ListNode* tail = dummy;

            while (list1 != nullptr && list2 != nullptr) {
                if (list1->val <= list2->val) {
                    tail->next = list1;
                    list1 = list1->next;
                } else {
                    tail->next = list2; 
                    list2 = list2->next; 
                }
                tail = tail->next;
            }

            if (list1 != nullptr) {
                tail->next = list1;
            } else if (list2 != nullptr) {
                tail->next = list2;
            }

            ListNode* result = dummy->next;
            delete dummy;
            return result;   
        }
    };
    ```

2. Analysis
- Time Complexity:  O(N), where N = m + n
    - list 1: O(m)
    - list 2: O(n)
    - total: O(m) + O(n) = O (m + n ) = O(N), where N = n + m
- Space Complexity: O(1)
    - dummy: O(1)
    - tail: O(1)
    - total: O(1) + O(1)

3. Note
- Linked List 問題使用 dummy node 優點
    - Head Node 可以不用特別處理, 所有 Node 加入的流程可以一致
    - 簡化 list1 or list2 爲 nullptr 的檢查
    - 因為是 Singly linked list, 多一個 dummy node 方便操作前一個 Node
- 2 ways to create dummy node
    - Allocate on the stack (No need to free memory manually!)
        ```c++
        ListNode dummy(0); 
        dummy.next = head;
        ListNode* curr = &dummy; 
        // ...
        return dummy.next;    
        ```
    - Allcocate on the heap (Need to free memory manually!)
        ```c++
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        // ...
        ListNode* newHead = dummy->next;
        delete dummy; 
        return newHead;
        ```
- heap 相關問題
     - 記憶體釋放需要手動 (free for C, delete for C++)
     - 忘記釋放: Memory Leak
     - 釋放兩次: Double Free
     - C++11 開始引入 Smart Pointer 解決這個問題, 
        - std::unique_ptr: 一個 heap 裡的記憶體空間只會被一個 unique_ptr 管理，當 unique_ptr 被 free 時，heap 裡的記憶體空間也會被 free.
        - std::shared_ptr: 一個 heap 裡的記憶體空間可以被多個 shared_ptr 管理, 底層會有 count 紀錄這個 heap 被幾個 shared_ptr 管理，當所有的 shared_ptr 被 free, heap 裡的記憶體空間才會被 free.
        - std::weak_ptr: 搭配 shared_ptr 使用的 smart pointer, weak_ptr 不會被底層的 count 紀錄進去，所以 weak_ptr 不會影響這個 heap 裡的記憶體空間被 free.
